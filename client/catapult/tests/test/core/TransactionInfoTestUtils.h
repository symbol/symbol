/**
*** Copyright (c) 2016-2019, Jaguar0625, gimre, BloodyRookie, Tech Bureau, Corp.
*** Copyright (c) 2020-present, Jaguar0625, gimre, BloodyRookie.
*** All rights reserved.
***
*** This file is part of Catapult.
***
*** Catapult is free software: you can redistribute it and/or modify
*** it under the terms of the GNU Lesser General Public License as published by
*** the Free Software Foundation, either version 3 of the License, or
*** (at your option) any later version.
***
*** Catapult is distributed in the hope that it will be useful,
*** but WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
*** GNU Lesser General Public License for more details.
***
*** You should have received a copy of the GNU Lesser General Public License
*** along with Catapult. If not, see <http://www.gnu.org/licenses/>.
**/

#pragma once
#include "catapult/model/ContainerTypes.h"
#include "catapult/model/EntityInfo.h"
#include "tests/TestHarness.h"
#include <vector>

namespace catapult { namespace test {

	// region create (single)

	/// Creates a random transaction info.
	model::TransactionInfo CreateRandomTransactionInfo();

	/// Creates a random transaction info with size \a entitySize.
	model::TransactionInfo CreateRandomTransactionInfoWithSize(uint32_t entitySize);

	/// Creates a transaction info composed of a random transaction with the specified \a deadline and a random hash.
	model::TransactionInfo CreateTransactionInfoWithDeadline(uint64_t deadline);

	// endregion

	// region create (multiple)

	/// Creates \a count transaction infos with deadlines in the range [1, \a count].
	std::vector<model::TransactionInfo> CreateTransactionInfos(size_t count);

	/// Creates \a count transaction infos with deadlines generated by \a deadlineGenerator.
	std::vector<model::TransactionInfo> CreateTransactionInfos(size_t count, const std::function<Timestamp (size_t)>& deadlineGenerator);

	/// Creates transaction infos from \a sizeMultiplierPairs such that each transaction has size equal to `pair::first`
	/// and max fee equal to `pair::first * pair::second / 10`.
	std::vector<model::TransactionInfo> CreateTransactionInfosFromSizeMultiplierPairs(
			const std::vector<std::pair<uint32_t, uint32_t>>& sizeMultiplierPairs);

	/// Creates \a count transaction infos with optional extracted addresses.
	std::vector<model::TransactionInfo> CreateTransactionInfosWithOptionalAddresses(size_t count);

	// endregion

	// region copy

	/// Creates a copy of transaction infos (\a transactionInfos).
	std::vector<model::TransactionInfo> CopyTransactionInfos(const std::vector<model::TransactionInfo>& transactionInfos);

	/// Creates a copy of transaction infos (\a transactionInfos) as a set.
	model::TransactionInfosSet CopyTransactionInfosToSet(const std::vector<model::TransactionInfo>& transactionInfos);

	// endregion

	// region extract

	/// Extracts all entities from transaction infos (\a transactionInfos).
	std::vector<const model::VerifiableEntity*> ExtractEntities(const std::vector<model::TransactionInfo>& transactionInfos);

	/// Extracts all hashes from transaction infos (\a transactionInfos).
	std::vector<Hash256> ExtractHashes(const std::vector<model::TransactionInfo>& transactionInfos);

	// endregion

	// region asserts

	/// Asserts that \a lhs and \a rhs are equal with \a message.
	template<typename TEntity>
	void AssertEqual(const model::EntityInfo<TEntity>& lhs, const model::EntityInfo<TEntity>& rhs, const std::string& message = "") {
		EXPECT_EQ(*lhs.pEntity, *rhs.pEntity) << message;
		EXPECT_EQ(lhs.EntityHash, rhs.EntityHash) << message;
	}

	/// Asserts that \a lhs and \a rhs are equal with \a message.
	void AssertEqual(
			const model::DetachedTransactionInfo& lhs,
			const model::DetachedTransactionInfo& rhs,
			const std::string& message = "");

	/// Asserts that \a lhs and \a rhs are equal with \a message.
	void AssertEqual(const model::TransactionInfo& lhs, const model::TransactionInfo& rhs, const std::string& message = "");

	/// Asserts that \a lhs is equal to \a rhs in any order with \a message.
	void AssertEquivalent(
			const std::vector<model::TransactionInfo>& lhs,
			const std::vector<model::TransactionInfo>& rhs,
			const std::string& message = "");

	/// Asserts that \a lhs is equal to \a rhs in any order with \a message.
	void AssertEquivalent(const model::TransactionInfosSet& lhs, const model::TransactionInfosSet& rhs, const std::string& message = "");

	// endregion
}}
