# test-vectors for Symbol projects

## crypto - for crypto-related algorithms

* 0.test-keccak-256 - Keccak 256 test vectors
* 0.test-sha3-256 - SHA3 256 test vectors

* 1.test-keys - deriviation of public key from private key
  * `KeyPair("privateKey").publicKey` == "publicKey"
* 1.test-address - deriviation of addresses in all networks from public key
  * `AddressToString(PublicKeyToAddress("publicKey", Public))` == "address\_Public"
  * `AddressToString(PublicKeyToAddress("publicKey", Public_Test))` == "address\_PublicTest"
  * `AddressToString(PublicKeyToAddress("publicKey", Private))` == "address\_Private"
  * `AddressToString(PublicKeyToAddress("publicKey", Private_Test))` == "address\_PrivateTest"
* 2.test-sign - ed25519 ECDSA signing (generation hash independent)
  * `KeyPair("privateKey").publicKey` == "publicKey"
  * `Sign(keyPair, "data", "length")` == "signature"
* 3.test-derive - shared key deriviation
  * `keyPair := KeyPair("privateKey")`
  * `DeriveSharedKey(keyPair, "otherPublicKey")` == "sharedKey"
  * scalarMulResult is an intermediate scalar multiplication result, prior to salting, can be ignored in most tests
* 4.test-cipher - AES256 GCM encryption with IV
  * `keyPair := KeyPair("privateKey")`
  * `sharedKey` := `DeriveSharedKey(keyPair, "otherPublicKey")`
  * `AesGcm256::TryDecrypt(sharedKey, "tag" || "iv" || "cipherText")` == "clearText"
* 5.test-mosaic-id - SHA3 256 mosaic id derivation
  * `GenerateMosaicId("address_Public, mosaicNonce")` == "mosaicId\_Public"
  * `GenerateMosaicId("address_PublicTest, mosaicNonce")` == "mosaicId\_PublicTest"
  * `GenerateMosaicId("address_Private, mosaicNonce")` == "mosaicId\_Private"
  * `GenerateMosaicId("address_PrivateTest, mosaicNonce")` == "mosaicId\_PrivateTest"
* 6.hd accounts - BIP32 derivation
  * `ExtendedKey.createFromSeed("seed")`
  * `ExtendedKey.derivePath("path_Public")`
  * `ExtendedKey.derivePath("path_Test")`

note, in test sets 3 and 4, "otherPublicKey" (other party's public key) is generated by incrementing 31st byte
of private key, and obtaining public key from that.

## serialization - for model (de)serialization

* basic - basic models
* states - state models
* transactions - transaction models
* invalid - invalid models
