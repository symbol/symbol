#!/usr/bin/python

from pathlib import Path

from catparser.ast import Array, Conditional, Enum, FixedSizeBuffer, FixedSizeInteger, Struct

from .AbstractImplMap import AbstractImplMap
from .ast_adapters import isinstance_builtin
from .EnumTypeFormatter import EnumTypeFormatter
from .FactoryFormatter import FactoryClassFormatter, FactoryFormatter
from .PodTypeFormatter import PodTypeFormatter
from .printers import BuiltinPrinter, create_pod_printer
from .StructTypeFormatter import StructFormatter
from .type_objects import ArrayObject, EnumObject, IntObject, StructObject
from .TypeFormatter import TypeFormatter


class Field:
	def __init__(self, ast_model, type_instance, printer):
		self.ast_model = ast_model
		self.original_field_name = ast_model.name
		self.type_instance = type_instance
		self.printer = printer
		self.bound_field = None
		self.size_fields = []

	def get_type(self):
		return self.type_instance

	def get_printer(self):
		return self.printer

	def set_bound_field(self, other_field):
		self.bound_field = other_field

	def is_bound(self):
		return self.bound_field is not None

	def add_sizeof_field(self, other_field):
		self.size_fields.append(other_field)

	def is_const(self):
		return hasattr(self.ast_model, 'disposition') and 'const' == self.ast_model.disposition

	def is_conditional(self):
		return isinstance(self.ast_model.value, Conditional)


def to_type_formatter_instance(type_instance):
	mapping = {
		'int': PodTypeFormatter,
		'array': PodTypeFormatter,
		'enum': EnumTypeFormatter,
		'struct': StructFormatter,
	}

	type_formatter = mapping[type_instance.base_typename]
	return type_formatter(type_instance)


def to_virtual_type_instance(ast_model):
	object_type = None
	if isinstance(ast_model, Struct):
		object_type = StructObject
	elif isinstance(ast_model, Enum):
		object_type = EnumObject
	elif isinstance_builtin(ast_model, FixedSizeBuffer):
		object_type = ArrayObject
	elif isinstance_builtin(ast_model, FixedSizeInteger):
		object_type = IntObject

	return object_type(ast_model)


def create_printer(type_instance, name):
	if type_instance.is_builtin:
		return BuiltinPrinter(type_instance, name)

	return create_pod_printer(type_instance, name)


def process_concrete_struct(type_map, struct_type, abstract_impl_map):
	factory_type = type_map[struct_type.ast_model.factory_type]

	discriminators = [] if not hasattr(factory_type, 'discriminator') else factory_type.discriminator
	for i, discriminator in enumerate(discriminators):
		discriminators[i] = discriminator

	abstract_impl_map.add(factory_type, struct_type)


def bind_size_fields(struct_type):
	# go through structs and bind size fields to arrays
	for field in struct_type.layout:
		if field.type_instance.is_array and isinstance(field.get_type().size, str):
			size_field_name = field.get_type().size
			size_field = struct_type.get_field_by_name(size_field_name)
			size_field.set_bound_field(field)

		if field.type_instance.sizeof_value:
			struct_field = struct_type.get_field_by_name(field.ast_model.value)
			field.set_bound_field(struct_field)

			struct_field.add_sizeof_field(field)


def process_struct(type_map, struct_type: StructObject, abstract_impl_map: AbstractImplMap):
	if struct_type.ast_model.factory_type:
		process_concrete_struct(type_map, struct_type, abstract_impl_map)

	for field_ast_model in struct_type.ast_model.fields:
		type_instance = type_map.get(field_ast_model.field_type, None)

		if isinstance(field_ast_model.field_type, Array):
			element_type = type_map.get(field_ast_model.field_type.element_type, None)
			if not element_type:
				element_type = to_virtual_type_instance(field_ast_model.field_type.element_type)

			type_instance = ArrayObject(field_ast_model)
			type_instance.element_type = element_type
			type_instance.is_builtin = False

		if not type_instance:
			type_instance = to_virtual_type_instance(field_ast_model)
			type_instance.is_builtin = False

		field_printer = create_printer(type_instance, field_ast_model.name)
		struct_type.add_field(Field(field_ast_model, type_instance, field_printer))

	bind_size_fields(struct_type)


def generate_files(ast_models, output_directory: Path):
	# build map of types
	type_map = {}
	abstract_impl_map = AbstractImplMap()

	types = []
	for ast_model in ast_models:
		instance = to_virtual_type_instance(ast_model)
		types.append(instance)
		type_map[ast_model.name] = instance

	# process struct fields
	for type_instance in types:
		if not type_instance.is_struct:
			continue

		process_struct(type_map, type_instance, abstract_impl_map)

	output_directory.mkdir(exist_ok=True)

	with open(output_directory / '__init__.py', 'w', encoding='utf8', newline='\n') as output_file:
		output_file.write(
			'''#!/usr/bin/python
#
# Code generated by catbuffer python generator; DO NOT EDIT.

from __future__ import annotations

from binascii import hexlify
from enum import Enum, Flag
from typing import ByteString, List, TypeVar

from ..ArrayHelpers import ArrayHelpers
from ..BaseValue import BaseValue
from ..ByteArray import ByteArray

# string or bytes
StrBytes = TypeVar('StrBytes', str, bytes)

'''
		)
		for type_instance in types:
			generator = TypeFormatter(to_type_formatter_instance(type_instance))
			output_file.write(str(generator))
			output_file.write('\n\n')

		factories = []
		for type_instance in types:
			if not (type_instance.is_struct and type_instance.is_abstract):
				continue

			factory_generator = FactoryClassFormatter(FactoryFormatter(abstract_impl_map, type_instance))
			factories.append(str(factory_generator))

		output_file.write('\n\n'.join(factories))


class Generator:
	@staticmethod
	def generate(ast_models, output):
		print(f'python catbuffer generator called with output: {output}')
		generate_files(ast_models, Path(output))
