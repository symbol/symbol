#!/usr/bin/python

from pathlib import Path

from catparser.DisplayType import DisplayType

from .AbstractImplMap import AbstractImplMap
from .EnumTypeFormatter import EnumTypeFormatter
from .FactoryFormatter import FactoryClassFormatter, FactoryFormatter
from .PodTypeFormatter import PodTypeFormatter
from .printers import BuiltinPrinter, create_pod_printer
from .StructTypeFormatter import StructFormatter
from .type_objects import BaseObject, StructObject
from .TypeFormatter import TypeFormatter


class Field:
	def __init__(self, ast_model, type_instance, printer):
		self.ast_model = ast_model
		self.type_ast_model = type_instance.ast_model

		self.printer = printer
		self.bound_field = None
		self.size_fields = []

	def get_printer(self):
		return self.printer

	def set_bound_field(self, other_field):
		self.bound_field = other_field

	def is_bound(self):
		return self.bound_field is not None

	def add_sizeof_field(self, other_field):
		self.size_fields.append(other_field)


def to_type_formatter_instance(type_instance):
	type_formatter_class = {
		DisplayType.STRUCT: StructFormatter,
		DisplayType.ENUM: EnumTypeFormatter,
		DisplayType.BYTE_ARRAY: PodTypeFormatter,
		DisplayType.INTEGER: PodTypeFormatter
	}[type_instance.ast_model.display_type]

	return type_formatter_class(type_instance)


def to_virtual_type_instance(ast_model):
	object_class = {
		DisplayType.STRUCT: StructObject,
		DisplayType.ENUM: BaseObject,
		DisplayType.BYTE_ARRAY: BaseObject,
		DisplayType.INTEGER: BaseObject
	}[ast_model.display_type]

	return object_class(ast_model)


def process_concrete_struct(type_map, struct_type, abstract_impl_map):
	factory_type = type_map[struct_type.ast_model.factory_type]

	discriminators = [] if not hasattr(factory_type, 'discriminator') else factory_type.discriminator
	for i, discriminator in enumerate(discriminators):
		discriminators[i] = discriminator

	abstract_impl_map.add(factory_type, struct_type)


def bind_size_fields(struct_type):
	# go through structs and bind size fields to arrays
	for field in struct_type.layout:
		if field.ast_model.display_type.is_array and isinstance(field.ast_model.size, str):
			size_field_name = field.ast_model.size
			size_field = struct_type.get_field_by_name(size_field_name)
			size_field.set_bound_field(field)

		if field.ast_model.is_size_reference:
			struct_field = struct_type.get_field_by_name(field.ast_model.value)
			field.set_bound_field(struct_field)

			struct_field.add_sizeof_field(field)


def process_struct(type_map, struct_type: StructObject, abstract_impl_map: AbstractImplMap):
	if struct_type.ast_model.factory_type:
		process_concrete_struct(type_map, struct_type, abstract_impl_map)

	for field_ast_model in struct_type.ast_model.fields:
		type_instance = type_map.get(field_ast_model.field_type, None)

		create_printer = create_pod_printer
		if DisplayType.TYPED_ARRAY == field_ast_model.display_type:
			element_type = type_map.get(field_ast_model.field_type.element_type, None)
			if not element_type:
				element_type = to_virtual_type_instance(field_ast_model.field_type.element_type)

			type_instance = BaseObject(field_ast_model)
			type_instance.is_contents_abstract = (
				DisplayType.STRUCT == element_type.ast_model.display_type and element_type.ast_model.is_abstract
			)
		elif not type_instance:
			type_instance = to_virtual_type_instance(field_ast_model)
		else:
			create_printer = BuiltinPrinter

		field_printer = create_printer(type_instance, field_ast_model.name)
		struct_type.add_field(Field(field_ast_model, type_instance, field_printer))

	bind_size_fields(struct_type)


def generate_files(ast_models, output_directory: Path):
	# build map of types
	type_map = {}
	abstract_impl_map = AbstractImplMap()

	types = []
	for ast_model in ast_models:
		instance = to_virtual_type_instance(ast_model)
		types.append(instance)
		type_map[ast_model.name] = instance

	# process struct fields
	for type_instance in types:
		if DisplayType.STRUCT == type_instance.ast_model.display_type:
			process_struct(type_map, type_instance, abstract_impl_map)

	output_directory.mkdir(exist_ok=True)

	with open(output_directory / '__init__.py', 'w', encoding='utf8', newline='\n') as output_file:
		output_file.write(
			'''#!/usr/bin/python
#
# Code generated by catbuffer python generator; DO NOT EDIT.

from __future__ import annotations

from binascii import hexlify
from enum import Enum, Flag
from typing import ByteString, List, TypeVar

from ..ArrayHelpers import ArrayHelpers
from ..BaseValue import BaseValue
from ..ByteArray import ByteArray

# string or bytes
StrBytes = TypeVar('StrBytes', str, bytes)

'''
		)
		for type_instance in types:
			generator = TypeFormatter(to_type_formatter_instance(type_instance))
			output_file.write(str(generator))
			output_file.write('\n\n')

		factories = []
		for type_instance in types:
			if DisplayType.STRUCT == type_instance.ast_model.display_type and type_instance.ast_model.is_abstract:
				factory_generator = FactoryClassFormatter(FactoryFormatter(abstract_impl_map, type_instance))
				factories.append(str(factory_generator))

		output_file.write('\n\n'.join(factories))


class Generator:
	@staticmethod
	def generate(ast_models, output):
		print(f'python catbuffer generator called with output: {output}')
		generate_files(ast_models, Path(output))
